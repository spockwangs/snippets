Warning : *** Shift/Reduce conflict found in state #72
  between tydecs ::= tydec (*) 
  and     tydec ::= (*) TYPE ID EQ ty 
  under symbol TYPE
  Resolved in favor of shifting.

Warning : *** Shift/Reduce conflict found in state #141
  between selection_exp ::= IF exp THEN exp (*) 
  and     selection_exp ::= IF exp THEN exp (*) ELSE exp 
  under symbol ELSE
  Resolved in favor of shifting.

Warning : *** Shift/Reduce conflict found in state #12
  between lvalue ::= ID (*) 
  and     X ::= ID (*) LBRACK exp RBRACK 
  under symbol LBRACK
  Resolved in favor of shifting.

Warning : *** Shift/Reduce conflict found in state #73
  between fundecs ::= fundec (*) 
  and     fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN EQ exp 
  and     fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp 
  under symbol FUNCTION
  Resolved in favor of shifting.

===== Terminals =====
[0]EOF [1]error [2]ID [3]STRING [4]INT 
[5]COMMA [6]COLON [7]SEMICOLON [8]LPAREN [9]RPAREN 
[10]LBRACK [11]RBRACK [12]LBRACE [13]RBRACE [14]DOT 
[15]PLUS [16]MINUS [17]TIMES [18]DIVIDE [19]EQ 
[20]NEQ [21]LT [22]LE [23]GT [24]GE 
[25]AND [26]OR [27]ASSIGN [28]ARRAY [29]IF 
[30]THEN [31]ELSE [32]WHILE [33]FOR [34]TO 
[35]DO [36]LET [37]IN [38]END [39]OF 
[40]BREAK [41]NIL [42]FUNCTION [43]VAR [44]TYPE 
[45]UMINUS 

===== Non terminals =====
[0]lvalue [1]program [2]exp [3]iteration_exp [4]binary_exp 
[5]expseq [6]block_exp [7]funcall [8]unary_exp [9]record_creation 
[10]array_creation [11]selection_exp [12]assignment_exp [13]jump_exp [14]let_exp 
[15]dec [16]decs [17]vardec [18]tydec [19]tydecs 
[20]fundec [21]fundecs [22]ty [23]argument_list [24]record_list 
[25]tyfieldlist [26]tyfields [27]X 

===== Productions =====
[0] $START ::= program EOF 
[1] program ::= exp 
[2] decs ::= 
[3] decs ::= dec decs 
[4] dec ::= tydecs 
[5] dec ::= vardec 
[6] dec ::= fundecs 
[7] tydecs ::= tydec 
[8] tydecs ::= tydec tydecs 
[9] tydec ::= TYPE ID EQ ty 
[10] ty ::= ID 
[11] ty ::= LBRACE tyfields RBRACE 
[12] ty ::= ARRAY OF ID 
[13] tyfields ::= 
[14] tyfields ::= tyfieldlist 
[15] tyfieldlist ::= ID COLON ID 
[16] tyfieldlist ::= ID COLON ID COMMA tyfieldlist 
[17] vardec ::= VAR ID ASSIGN exp 
[18] vardec ::= VAR ID COLON ID ASSIGN exp 
[19] fundecs ::= fundec 
[20] fundecs ::= fundec fundecs 
[21] fundec ::= FUNCTION ID LPAREN tyfields RPAREN EQ exp 
[22] fundec ::= FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp 
[23] lvalue ::= ID 
[24] lvalue ::= lvalue DOT ID 
[25] lvalue ::= X 
[26] lvalue ::= lvalue LBRACK exp RBRACK 
[27] X ::= ID LBRACK exp RBRACK 
[28] exp ::= lvalue 
[29] exp ::= NIL 
[30] exp ::= block_exp 
[31] exp ::= INT 
[32] exp ::= STRING 
[33] exp ::= funcall 
[34] exp ::= unary_exp 
[35] exp ::= binary_exp 
[36] exp ::= record_creation 
[37] exp ::= array_creation 
[38] exp ::= assignment_exp 
[39] exp ::= selection_exp 
[40] exp ::= iteration_exp 
[41] exp ::= jump_exp 
[42] exp ::= let_exp 
[43] block_exp ::= LPAREN expseq RPAREN 
[44] expseq ::= 
[45] expseq ::= exp 
[46] expseq ::= exp SEMICOLON expseq 
[47] funcall ::= ID LPAREN argument_list RPAREN 
[48] argument_list ::= 
[49] argument_list ::= exp 
[50] argument_list ::= exp COLON argument_list 
[51] unary_exp ::= MINUS exp 
[52] binary_exp ::= exp PLUS exp 
[53] binary_exp ::= exp MINUS exp 
[54] binary_exp ::= exp TIMES exp 
[55] binary_exp ::= exp DIVIDE exp 
[56] binary_exp ::= exp EQ exp 
[57] binary_exp ::= exp NEQ exp 
[58] binary_exp ::= exp GT exp 
[59] binary_exp ::= exp LT exp 
[60] binary_exp ::= exp GE exp 
[61] binary_exp ::= exp LE exp 
[62] binary_exp ::= exp AND exp 
[63] binary_exp ::= exp OR exp 
[64] record_creation ::= ID LBRACE RBRACE 
[65] record_creation ::= ID LBRACE record_list RBRACE 
[66] record_list ::= ID EQ exp 
[67] record_list ::= ID EQ exp COLON record_list 
[68] array_creation ::= X OF exp 
[69] assignment_exp ::= lvalue ASSIGN exp 
[70] selection_exp ::= IF exp THEN exp 
[71] selection_exp ::= IF exp THEN exp ELSE exp 
[72] iteration_exp ::= WHILE exp DO exp 
[73] iteration_exp ::= FOR ID ASSIGN exp TO exp DO exp 
[74] jump_exp ::= BREAK 
[75] let_exp ::= LET decs IN expseq END 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [array_creation ::= (*) X OF exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) jump_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [program ::= (*) exp , {EOF }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) selection_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) binary_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) iteration_exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) record_creation , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
  [$START ::= (*) program EOF , {EOF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on program to state [9]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [6]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [1]: {
  [exp ::= selection_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [2]: {
  [exp ::= unary_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [3]: {
  [array_creation ::= X (*) OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= X (*) , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OF to state [147]

-------------------
lalr_state [4]: {
  [exp ::= INT (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [5]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [iteration_exp ::= WHILE (*) exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [144]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [6]: {
  [binary_exp ::= exp (*) OR exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) NEQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) TIMES exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) AND exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) EQ exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) MINUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [program ::= exp (*) , {EOF }]
  [binary_exp ::= exp (*) LE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GT exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) PLUS exp , {EOF PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [7]: {
  [exp ::= jump_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [8]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [selection_exp ::= IF (*) exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [selection_exp ::= IF (*) exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [139]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [9]: {
  [$START ::= program (*) EOF , {EOF }]
}
transition on EOF to state [138]

-------------------
lalr_state [10]: {
  [array_creation ::= (*) X OF exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) jump_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [expseq ::= (*) exp SEMICOLON expseq , {RPAREN }]
  [exp ::= (*) array_creation , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= LPAREN (*) expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) selection_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [expseq ::= (*) , {RPAREN }]
  [exp ::= (*) binary_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) iteration_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [expseq ::= (*) exp , {RPAREN }]
  [exp ::= (*) record_creation , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on expseq to state [136]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [111]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [11]: {
  [exp ::= NIL (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [12]: {
  [X ::= ID (*) LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
  [record_creation ::= ID (*) LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= ID (*) , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= ID (*) LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= ID (*) LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on LPAREN to state [120]
transition on LBRACK to state [119]
transition on LBRACE to state [118]

-------------------
lalr_state [13]: {
  [exp ::= array_creation (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [14]: {
  [exp ::= assignment_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [15]: {
  [exp ::= STRING (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [16]: {
  [exp ::= funcall (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [17]: {
  [jump_exp ::= BREAK (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [18]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= MINUS (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [117]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [19]: {
  [fundecs ::= (*) fundec fundecs , {IN FUNCTION VAR TYPE }]
  [vardec ::= (*) VAR ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [tydecs ::= (*) tydec tydecs , {IN FUNCTION VAR TYPE }]
  [dec ::= (*) vardec , {IN FUNCTION VAR TYPE }]
  [decs ::= (*) , {IN }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [fundecs ::= (*) fundec , {IN FUNCTION VAR TYPE }]
  [tydecs ::= (*) tydec , {IN FUNCTION VAR TYPE }]
  [dec ::= (*) tydecs , {IN FUNCTION VAR TYPE }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [vardec ::= (*) VAR ID COLON ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [tydec ::= (*) TYPE ID EQ ty , {IN FUNCTION VAR TYPE }]
  [let_exp ::= LET (*) decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [dec ::= (*) fundecs , {IN FUNCTION VAR TYPE }]
  [decs ::= (*) dec decs , {IN }]
}
transition on FUNCTION to state [74]
transition on fundec to state [73]
transition on tydec to state [72]
transition on TYPE to state [71]
transition on VAR to state [70]
transition on tydecs to state [69]
transition on decs to state [68]
transition on vardec to state [67]
transition on dec to state [66]
transition on fundecs to state [65]

-------------------
lalr_state [20]: {
  [exp ::= iteration_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [21]: {
  [iteration_exp ::= FOR (*) ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on ID to state [58]

-------------------
lalr_state [22]: {
  [exp ::= binary_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [23]: {
  [lvalue ::= lvalue (*) DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= lvalue (*) LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= lvalue (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= lvalue (*) ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on DOT to state [29]
transition on ASSIGN to state [28]
transition on LBRACK to state [27]

-------------------
lalr_state [24]: {
  [exp ::= let_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [25]: {
  [exp ::= record_creation (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [26]: {
  [exp ::= block_exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [27]: {
  [array_creation ::= (*) X OF exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) jump_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) selection_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= lvalue LBRACK (*) exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) iteration_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) record_creation , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [56]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [28]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= lvalue ASSIGN (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [31]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [29]: {
  [lvalue ::= lvalue DOT (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on ID to state [30]

-------------------
lalr_state [30]: {
  [lvalue ::= lvalue DOT ID (*) , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [31]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= lvalue ASSIGN exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [32]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp MINUS (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [55]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [33]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp AND (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [54]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [34]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp DIVIDE (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [53]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [35]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp GE (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [52]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [36]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp NEQ (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [51]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [37]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp PLUS (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [50]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [38]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp EQ (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [49]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [39]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp LE (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [48]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [40]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp GT (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [47]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [41]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp TIMES (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [46]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [42]: {
  [binary_exp ::= exp LT (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [45]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [43]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp OR (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [44]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [44]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp OR exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [45]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp LT exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [46]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp TIMES exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [47]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp GT exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [48]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp LE exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [49]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp EQ exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [50]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp PLUS exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [51]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp NEQ exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [52]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp GE exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [53]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp DIVIDE exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [54]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp AND exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [55]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp MINUS exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [56]: {
  [binary_exp ::= exp (*) OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= lvalue LBRACK exp (*) RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on RBRACK to state [57]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [57]: {
  [lvalue ::= lvalue LBRACK exp RBRACK (*) , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [58]: {
  [iteration_exp ::= FOR ID (*) ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on ASSIGN to state [59]

-------------------
lalr_state [59]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
  [iteration_exp ::= FOR ID ASSIGN (*) exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN TO OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [60]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [60]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [iteration_exp ::= FOR ID ASSIGN exp (*) TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR TO }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on TO to state [61]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [61]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [iteration_exp ::= FOR ID ASSIGN exp TO (*) exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN DO OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [62]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [62]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [iteration_exp ::= FOR ID ASSIGN exp TO exp (*) DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on DO to state [63]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [63]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= FOR ID ASSIGN exp TO exp DO (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [64]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [64]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= FOR ID ASSIGN exp TO exp DO exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [65]: {
  [dec ::= fundecs (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [66]: {
  [fundecs ::= (*) fundec fundecs , {IN FUNCTION VAR TYPE }]
  [vardec ::= (*) VAR ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [tydecs ::= (*) tydec tydecs , {IN FUNCTION VAR TYPE }]
  [dec ::= (*) vardec , {IN FUNCTION VAR TYPE }]
  [decs ::= (*) , {IN }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [fundecs ::= (*) fundec , {IN FUNCTION VAR TYPE }]
  [tydecs ::= (*) tydec , {IN FUNCTION VAR TYPE }]
  [dec ::= (*) tydecs , {IN FUNCTION VAR TYPE }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [vardec ::= (*) VAR ID COLON ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [tydec ::= (*) TYPE ID EQ ty , {IN FUNCTION VAR TYPE }]
  [decs ::= dec (*) decs , {IN }]
  [dec ::= (*) fundecs , {IN FUNCTION VAR TYPE }]
  [decs ::= (*) dec decs , {IN }]
}
transition on FUNCTION to state [74]
transition on fundec to state [73]
transition on tydec to state [72]
transition on TYPE to state [71]
transition on VAR to state [70]
transition on tydecs to state [69]
transition on decs to state [116]
transition on vardec to state [67]
transition on dec to state [66]
transition on fundecs to state [65]

-------------------
lalr_state [67]: {
  [dec ::= vardec (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [68]: {
  [let_exp ::= LET decs (*) IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on IN to state [110]

-------------------
lalr_state [69]: {
  [dec ::= tydecs (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [70]: {
  [vardec ::= VAR (*) ID COLON ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [vardec ::= VAR (*) ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [103]

-------------------
lalr_state [71]: {
  [tydec ::= TYPE (*) ID EQ ty , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [93]

-------------------
lalr_state [72]: {
  [tydecs ::= (*) tydec tydecs , {IN FUNCTION VAR TYPE }]
  [tydecs ::= tydec (*) , {IN FUNCTION VAR TYPE }]
  [tydecs ::= (*) tydec , {IN FUNCTION VAR TYPE }]
  [tydec ::= (*) TYPE ID EQ ty , {IN FUNCTION VAR TYPE }]
  [tydecs ::= tydec (*) tydecs , {IN FUNCTION VAR TYPE }]
}
transition on TYPE to state [71]
transition on tydec to state [72]
transition on tydecs to state [92]

-------------------
lalr_state [73]: {
  [fundecs ::= (*) fundec , {IN FUNCTION VAR TYPE }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [fundecs ::= fundec (*) fundecs , {IN FUNCTION VAR TYPE }]
  [fundecs ::= (*) fundec fundecs , {IN FUNCTION VAR TYPE }]
  [fundec ::= (*) FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [fundecs ::= fundec (*) , {IN FUNCTION VAR TYPE }]
}
transition on FUNCTION to state [74]
transition on fundec to state [73]
transition on fundecs to state [91]

-------------------
lalr_state [74]: {
  [fundec ::= FUNCTION (*) ID LPAREN tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION (*) ID LPAREN tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [75]

-------------------
lalr_state [75]: {
  [fundec ::= FUNCTION ID (*) LPAREN tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID (*) LPAREN tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on LPAREN to state [76]

-------------------
lalr_state [76]: {
  [fundec ::= FUNCTION ID LPAREN (*) tyfields RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
  [tyfieldlist ::= (*) ID COLON ID COMMA tyfieldlist , {RPAREN }]
  [tyfields ::= (*) , {RPAREN }]
  [tyfieldlist ::= (*) ID COLON ID , {RPAREN }]
  [fundec ::= FUNCTION ID LPAREN (*) tyfields RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [tyfields ::= (*) tyfieldlist , {RPAREN }]
}
transition on tyfieldlist to state [79]
transition on tyfields to state [78]
transition on ID to state [77]

-------------------
lalr_state [77]: {
  [tyfieldlist ::= ID (*) COLON ID COMMA tyfieldlist , {RPAREN RBRACE }]
  [tyfieldlist ::= ID (*) COLON ID , {RPAREN RBRACE }]
}
transition on COLON to state [87]

-------------------
lalr_state [78]: {
  [fundec ::= FUNCTION ID LPAREN tyfields (*) RPAREN COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields (*) RPAREN EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on RPAREN to state [80]

-------------------
lalr_state [79]: {
  [tyfields ::= tyfieldlist (*) , {RPAREN RBRACE }]
}

-------------------
lalr_state [80]: {
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN (*) COLON ID EQ exp , {IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN (*) EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on COLON to state [82]
transition on EQ to state [81]

-------------------
lalr_state [81]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN EQ (*) exp , {IN FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [86]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [82]: {
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN COLON (*) ID EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [83]

-------------------
lalr_state [83]: {
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN COLON ID (*) EQ exp , {IN FUNCTION VAR TYPE }]
}
transition on EQ to state [84]

-------------------
lalr_state [84]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ (*) exp , {IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [85]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [85]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp (*) , {IN FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [86]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [fundec ::= FUNCTION ID LPAREN tyfields RPAREN EQ exp (*) , {IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [87]: {
  [tyfieldlist ::= ID COLON (*) ID , {RPAREN RBRACE }]
  [tyfieldlist ::= ID COLON (*) ID COMMA tyfieldlist , {RPAREN RBRACE }]
}
transition on ID to state [88]

-------------------
lalr_state [88]: {
  [tyfieldlist ::= ID COLON ID (*) , {RPAREN RBRACE }]
  [tyfieldlist ::= ID COLON ID (*) COMMA tyfieldlist , {RPAREN RBRACE }]
}
transition on COMMA to state [89]

-------------------
lalr_state [89]: {
  [tyfieldlist ::= (*) ID COLON ID COMMA tyfieldlist , {RPAREN RBRACE }]
  [tyfieldlist ::= (*) ID COLON ID , {RPAREN RBRACE }]
  [tyfieldlist ::= ID COLON ID COMMA (*) tyfieldlist , {RPAREN RBRACE }]
}
transition on tyfieldlist to state [90]
transition on ID to state [77]

-------------------
lalr_state [90]: {
  [tyfieldlist ::= ID COLON ID COMMA tyfieldlist (*) , {RPAREN RBRACE }]
}

-------------------
lalr_state [91]: {
  [fundecs ::= fundec fundecs (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [92]: {
  [tydecs ::= tydec tydecs (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [93]: {
  [tydec ::= TYPE ID (*) EQ ty , {IN FUNCTION VAR TYPE }]
}
transition on EQ to state [94]

-------------------
lalr_state [94]: {
  [ty ::= (*) ID , {IN FUNCTION VAR TYPE }]
  [tydec ::= TYPE ID EQ (*) ty , {IN FUNCTION VAR TYPE }]
  [ty ::= (*) ARRAY OF ID , {IN FUNCTION VAR TYPE }]
  [ty ::= (*) LBRACE tyfields RBRACE , {IN FUNCTION VAR TYPE }]
}
transition on ARRAY to state [98]
transition on LBRACE to state [97]
transition on ID to state [96]
transition on ty to state [95]

-------------------
lalr_state [95]: {
  [tydec ::= TYPE ID EQ ty (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [96]: {
  [ty ::= ID (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [97]: {
  [tyfieldlist ::= (*) ID COLON ID COMMA tyfieldlist , {RBRACE }]
  [tyfields ::= (*) , {RBRACE }]
  [tyfieldlist ::= (*) ID COLON ID , {RBRACE }]
  [tyfields ::= (*) tyfieldlist , {RBRACE }]
  [ty ::= LBRACE (*) tyfields RBRACE , {IN FUNCTION VAR TYPE }]
}
transition on tyfieldlist to state [79]
transition on tyfields to state [101]
transition on ID to state [77]

-------------------
lalr_state [98]: {
  [ty ::= ARRAY (*) OF ID , {IN FUNCTION VAR TYPE }]
}
transition on OF to state [99]

-------------------
lalr_state [99]: {
  [ty ::= ARRAY OF (*) ID , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [100]

-------------------
lalr_state [100]: {
  [ty ::= ARRAY OF ID (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [101]: {
  [ty ::= LBRACE tyfields (*) RBRACE , {IN FUNCTION VAR TYPE }]
}
transition on RBRACE to state [102]

-------------------
lalr_state [102]: {
  [ty ::= LBRACE tyfields RBRACE (*) , {IN FUNCTION VAR TYPE }]
}

-------------------
lalr_state [103]: {
  [vardec ::= VAR ID (*) COLON ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
  [vardec ::= VAR ID (*) ASSIGN exp , {IN FUNCTION VAR TYPE }]
}
transition on ASSIGN to state [105]
transition on COLON to state [104]

-------------------
lalr_state [104]: {
  [vardec ::= VAR ID COLON (*) ID ASSIGN exp , {IN FUNCTION VAR TYPE }]
}
transition on ID to state [107]

-------------------
lalr_state [105]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [vardec ::= VAR ID ASSIGN (*) exp , {IN FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [106]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [106]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [vardec ::= VAR ID ASSIGN exp (*) , {IN FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [107]: {
  [vardec ::= VAR ID COLON ID (*) ASSIGN exp , {IN FUNCTION VAR TYPE }]
}
transition on ASSIGN to state [108]

-------------------
lalr_state [108]: {
  [array_creation ::= (*) X OF exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [vardec ::= VAR ID COLON ID ASSIGN (*) exp , {IN FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN IN OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [109]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [109]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [vardec ::= VAR ID COLON ID ASSIGN exp (*) , {IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR IN FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [110]: {
  [array_creation ::= (*) X OF exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp LT exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) jump_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) STRING , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) ID , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [record_creation ::= (*) ID LBRACE RBRACE , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp DIVIDE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) exp SEMICOLON expseq , {END }]
  [exp ::= (*) array_creation , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) lvalue , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp GE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [unary_exp ::= (*) MINUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) let_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) funcall , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) lvalue DOT ID , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [jump_exp ::= (*) BREAK , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp EQ exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) assignment_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) NIL , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [selection_exp ::= (*) IF exp THEN exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp LE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp PLUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) unary_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) X , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [let_exp ::= LET decs IN (*) expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp NEQ exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) selection_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) block_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp AND exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp MINUS exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) , {END }]
  [exp ::= (*) binary_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [binary_exp ::= (*) exp GT exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) iteration_exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) INT , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [iteration_exp ::= (*) WHILE exp DO exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp OR exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp TIMES exp , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) exp , {END }]
  [exp ::= (*) record_creation , {SEMICOLON PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [X ::= (*) ID LBRACK exp RBRACK , {SEMICOLON LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on expseq to state [112]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [111]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [111]: {
  [binary_exp ::= exp (*) OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= exp (*) , {RPAREN END }]
  [binary_exp ::= exp (*) AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= exp (*) PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= exp (*) SEMICOLON expseq , {RPAREN END }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on SEMICOLON to state [114]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [112]: {
  [let_exp ::= LET decs IN expseq (*) END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on END to state [113]

-------------------
lalr_state [113]: {
  [let_exp ::= LET decs IN expseq END (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [114]: {
  [array_creation ::= (*) X OF exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp LT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) jump_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) STRING , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) ID , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [record_creation ::= (*) ID LBRACE RBRACE , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= exp SEMICOLON (*) expseq , {RPAREN END }]
  [binary_exp ::= (*) exp DIVIDE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) exp SEMICOLON expseq , {RPAREN END }]
  [exp ::= (*) array_creation , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) lvalue , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp GE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [unary_exp ::= (*) MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) let_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) funcall , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) lvalue DOT ID , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [jump_exp ::= (*) BREAK , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp EQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) assignment_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) NIL , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [selection_exp ::= (*) IF exp THEN exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp LE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp PLUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) unary_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) X , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [let_exp ::= (*) LET decs IN expseq END , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp NEQ exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) selection_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) block_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp AND exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp MINUS exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) , {RPAREN END }]
  [exp ::= (*) binary_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END }]
  [binary_exp ::= (*) exp GT exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) iteration_exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [exp ::= (*) INT , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [iteration_exp ::= (*) WHILE exp DO exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp OR exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [binary_exp ::= (*) exp TIMES exp , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [expseq ::= (*) exp , {RPAREN END }]
  [exp ::= (*) record_creation , {SEMICOLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR END }]
  [X ::= (*) ID LBRACK exp RBRACK , {SEMICOLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN END OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on expseq to state [115]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [111]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [115]: {
  [expseq ::= exp SEMICOLON expseq (*) , {RPAREN END }]
}

-------------------
lalr_state [116]: {
  [decs ::= dec decs (*) , {IN }]
}

-------------------
lalr_state [117]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= MINUS exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [118]: {
  [record_creation ::= ID LBRACE (*) record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= ID LBRACE (*) RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_list ::= (*) ID EQ exp COLON record_list , {RBRACE }]
  [record_list ::= (*) ID EQ exp , {RBRACE }]
}
transition on record_list to state [130]
transition on RBRACE to state [129]
transition on ID to state [128]

-------------------
lalr_state [119]: {
  [array_creation ::= (*) X OF exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) jump_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) selection_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) binary_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) iteration_exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= ID LBRACK (*) exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [126]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [120]: {
  [array_creation ::= (*) X OF exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) exp COLON argument_list , {RPAREN }]
  [exp ::= (*) jump_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= ID LPAREN (*) argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) , {RPAREN }]
  [exp ::= (*) selection_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) binary_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) exp , {RPAREN }]
  [exp ::= (*) iteration_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) record_creation , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on argument_list to state [122]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [121]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [121]: {
  [binary_exp ::= exp (*) OR exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) NEQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) TIMES exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) AND exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) EQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) MINUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= exp (*) COLON argument_list , {RPAREN }]
  [binary_exp ::= exp (*) LE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) DIVIDE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) PLUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= exp (*) , {RPAREN }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on COLON to state [124]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [122]: {
  [funcall ::= ID LPAREN argument_list (*) RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on RPAREN to state [123]

-------------------
lalr_state [123]: {
  [funcall ::= ID LPAREN argument_list RPAREN (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [124]: {
  [array_creation ::= (*) X OF exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= exp COLON (*) argument_list , {RPAREN }]
  [binary_exp ::= (*) exp LT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) exp COLON argument_list , {RPAREN }]
  [exp ::= (*) jump_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [let_exp ::= (*) LET decs IN expseq END , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) , {RPAREN }]
  [exp ::= (*) selection_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) binary_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [binary_exp ::= (*) exp GT exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [argument_list ::= (*) exp , {RPAREN }]
  [exp ::= (*) iteration_exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) record_creation , {COLON RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {COLON RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on argument_list to state [125]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [121]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [125]: {
  [argument_list ::= exp COLON argument_list (*) , {RPAREN }]
}

-------------------
lalr_state [126]: {
  [binary_exp ::= exp (*) OR exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) NEQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) TIMES exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) AND exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= ID LBRACK exp (*) RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) MINUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GT exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) DIVIDE exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) PLUS exp , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on RBRACK to state [127]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [127]: {
  [X ::= ID LBRACK exp RBRACK (*) , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}

-------------------
lalr_state [128]: {
  [record_list ::= ID (*) EQ exp COLON record_list , {RBRACE }]
  [record_list ::= ID (*) EQ exp , {RBRACE }]
}
transition on EQ to state [132]

-------------------
lalr_state [129]: {
  [record_creation ::= ID LBRACE RBRACE (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [130]: {
  [record_creation ::= ID LBRACE record_list (*) RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on RBRACE to state [131]

-------------------
lalr_state [131]: {
  [record_creation ::= ID LBRACE record_list RBRACE (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [132]: {
  [array_creation ::= (*) X OF exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LT exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) jump_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) STRING , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) ID , {COLON LBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE RBRACE , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp DIVIDE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) array_creation , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) lvalue , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp GE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [unary_exp ::= (*) MINUS exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) let_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) funcall , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue DOT ID , {COLON LBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [jump_exp ::= (*) BREAK , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp EQ exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) assignment_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) NIL , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp LE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp PLUS exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) unary_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) X , {COLON LBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [record_list ::= ID EQ (*) exp , {RBRACE }]
  [let_exp ::= (*) LET decs IN expseq END , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp NEQ exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) selection_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) block_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp AND exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp MINUS exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) binary_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {COLON LBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [record_list ::= ID EQ (*) exp COLON record_list , {RBRACE }]
  [binary_exp ::= (*) exp GT exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) iteration_exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) INT , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [iteration_exp ::= (*) WHILE exp DO exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp OR exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= (*) exp TIMES exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [exp ::= (*) record_creation , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [X ::= (*) ID LBRACK exp RBRACK , {COLON LBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN OF }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [133]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [133]: {
  [binary_exp ::= exp (*) OR exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) NEQ exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) TIMES exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) AND exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) LT exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) EQ exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) MINUS exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_list ::= ID EQ exp (*) COLON record_list , {RBRACE }]
  [binary_exp ::= exp (*) LE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) GT exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) DIVIDE exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [binary_exp ::= exp (*) PLUS exp , {COLON RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR }]
  [record_list ::= ID EQ exp (*) , {RBRACE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on COLON to state [134]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [134]: {
  [record_list ::= ID EQ exp COLON (*) record_list , {RBRACE }]
  [record_list ::= (*) ID EQ exp COLON record_list , {RBRACE }]
  [record_list ::= (*) ID EQ exp , {RBRACE }]
}
transition on record_list to state [135]
transition on ID to state [128]

-------------------
lalr_state [135]: {
  [record_list ::= ID EQ exp COLON record_list (*) , {RBRACE }]
}

-------------------
lalr_state [136]: {
  [block_exp ::= LPAREN expseq (*) RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on RPAREN to state [137]

-------------------
lalr_state [137]: {
  [block_exp ::= LPAREN expseq RPAREN (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}

-------------------
lalr_state [138]: {
  [$START ::= program EOF (*) , {EOF }]
}

-------------------
lalr_state [139]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [selection_exp ::= IF exp (*) THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [selection_exp ::= IF exp (*) THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on THEN to state [140]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [140]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN (*) exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [141]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [141]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN exp (*) ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on ELSE to state [142]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [142]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN exp ELSE (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [143]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [143]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= IF exp THEN exp ELSE exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [144]: {
  [binary_exp ::= exp (*) OR exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) GE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) NEQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) TIMES exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) AND exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) LT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) EQ exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) MINUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) LE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) GT exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [binary_exp ::= exp (*) DIVIDE exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
  [iteration_exp ::= WHILE exp (*) DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR DO }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on DO to state [145]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [145]: {
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= WHILE exp DO (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [146]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [146]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= WHILE exp DO exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
lalr_state [147]: {
  [array_creation ::= X OF (*) exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [array_creation ::= (*) X OF exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) jump_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) STRING , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) FOR ID ASSIGN exp TO exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) array_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) lvalue , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [assignment_exp ::= (*) lvalue ASSIGN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [unary_exp ::= (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) let_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) funcall , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue DOT ID , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [jump_exp ::= (*) BREAK , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [record_creation ::= (*) ID LBRACE record_list RBRACE , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [funcall ::= (*) ID LPAREN argument_list RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) assignment_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) NIL , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [block_exp ::= (*) LPAREN expseq RPAREN , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) unary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) X , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [let_exp ::= (*) LET decs IN expseq END , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) selection_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) block_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [selection_exp ::= (*) IF exp THEN exp ELSE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) binary_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [lvalue ::= (*) lvalue LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) iteration_exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) INT , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [iteration_exp ::= (*) WHILE exp DO exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= (*) exp TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [exp ::= (*) record_creation , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [X ::= (*) ID LBRACK exp RBRACK , {EOF COLON SEMICOLON RPAREN LBRACK RBRACK RBRACE DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN THEN ELSE TO DO IN END OF FUNCTION VAR TYPE }]
}
transition on block_exp to state [26]
transition on record_creation to state [25]
transition on let_exp to state [24]
transition on lvalue to state [23]
transition on binary_exp to state [22]
transition on FOR to state [21]
transition on iteration_exp to state [20]
transition on LET to state [19]
transition on MINUS to state [18]
transition on BREAK to state [17]
transition on funcall to state [16]
transition on STRING to state [15]
transition on assignment_exp to state [14]
transition on array_creation to state [13]
transition on ID to state [12]
transition on NIL to state [11]
transition on LPAREN to state [10]
transition on IF to state [8]
transition on jump_exp to state [7]
transition on exp to state [148]
transition on WHILE to state [5]
transition on INT to state [4]
transition on X to state [3]
transition on unary_exp to state [2]
transition on selection_exp to state [1]

-------------------
lalr_state [148]: {
  [binary_exp ::= exp (*) OR exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) NEQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) TIMES exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [array_creation ::= X OF exp (*) , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) AND exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) EQ exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) MINUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) LE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) GT exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) DIVIDE exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
  [binary_exp ::= exp (*) PLUS exp , {EOF COLON SEMICOLON RPAREN RBRACK RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR THEN ELSE TO DO IN END FUNCTION VAR TYPE }]
}
transition on OR to state [43]
transition on LT to state [42]
transition on TIMES to state [41]
transition on GT to state [40]
transition on LE to state [39]
transition on EQ to state [38]
transition on PLUS to state [37]
transition on NEQ to state [36]
transition on GE to state [35]
transition on DIVIDE to state [34]
transition on AND to state [33]
transition on MINUS to state [32]

-------------------
------- CUP v0.11a beta 20060608 Parser Generation Summary -------
  0 errors and 4 warnings
  46 terminals, 28 non-terminals, and 76 productions declared, 
  producing 149 unique parse states.
  0 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  4 conflicts detected (4 expected).
  Code written to "Grm.java", and "sym.java".
---------------------------------------------------- (v0.11a beta 20060608)
