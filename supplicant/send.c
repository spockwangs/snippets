#include "send.h"
#include "supplicant.h"
#include "md5.h"

u_char ruijie1[] = {
    0xff, 0xff, 0x37, 0x77, 0xff, 0xac,
    0xb1, 0x97, 0xa0, 0x00, 0x00, 0x00,
    0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xf2, 0x85, 0x00,
    0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
    0x31, 0x78, 0x2e, 0x65, 0x78, 0x65,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x11, 0x00, 0x28, 0x1a, 0x28,
    0x00, 0x00, 0x13, 0x11, 0x17, 0x22,
    0x92, 0x68, 0x64, 0x66, 0x92, 0x94,
    0x62, 0x66, 0x91, 0x93, 0x95, 0x62,
    0x93, 0x93, 0x91, 0x94, 0x64, 0x61,
    0x64, 0x64, 0x65, 0x66, 0x68, 0x94,
    0x98, 0xa7, 0x61, 0x67, 0x65, 0x67,
    0x9c, 0x6b
};

u_char ruijie2[] = {
    0xff, 0xff, 0x37, 0x77, 0xff, 0xac,
    0xb1, 0x97, 0xa0, 0x00, 0x00, 0x00,
    0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xf2, 0x85, 0x00,
    0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
    0x31, 0x78, 0x2e, 0x65, 0x78, 0x65,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00,
};

u_char ruijie3[] = {
    0xff, 0xff, 0x37, 0x77, 0xff, 0xac,
    0xb1, 0x97, 0xa0, 0x00, 0x00, 0x00,
    0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xf2, 0x85, 0x00,
    0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
    0x31, 0x78, 0x2e, 0x65, 0x78, 0x65,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x11, 0x00, 0x28, 0x1a, 0x28,
    0x00, 0x00, 0x13, 0x11, 0x17, 0x22,
    0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
    0x96, 0x96, 0x96, 0x96, 0x96, 0x96,
    0x67, 0x61, 0x96, 0x96, 0x64, 0x62,
    0x67, 0x91, 0x96, 0x96, 0x96, 0x96,
    0x9e, 0xc9, 0xcd, 0x96, 0x67, 0x67,
    0x98, 0x96, 0x00, 0x00, 0x13, 0x11,
    0x18, 0x06, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00,
};

u_char ruijie4[] = {
    0xff, 0xff, 0x37, 0x77, 0x7f, 0x9f,
    0xf7, 0xff, 0x01, 0xc3, 0xff, 0xff,
    0x37, 0x77, 0x7f, 0x9f, 0xf7, 0xff,
    0xff, 0x2b, 0xff, 0xff, 0x37, 0x77,
    0x7f, 0x3f, 0xff,
};


void send_eap_start(struct libnet_link_int *l,
                    struct ether_addr *dst, struct ether_addr *src)
{
    assert(l != NULL && dst != NULL && src != NULL);

    static u_char buf[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x88, 0x8E, 0x01, EAPOL_START, 0x00, 0x00,
        0xff, 0xff, 0x37, 0x77, 0xff, 0xac,
        0xb1, 0x97, 0xa0, 0x00, 0x00, 0x00,
        0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xf2, 0x85, 0x00,
        0x00, 0x13, 0x11, 0x38, 0x30, 0x32,
        0x31, 0x78, 0x2e, 0x65, 0x78, 0x65,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
        0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x13, 0x11, 0x00, 0x28, 0x1a, 0x28,
        0x00, 0x00, 0x13, 0x11, 0x17, 0x22,
        0x92, 0x68, 0x64, 0x66, 0x92, 0x94,
        0x62, 0x66, 0x91, 0x93, 0x95, 0x62,
        0x93, 0x93, 0x91, 0x94, 0x64, 0x61,
        0x64, 0x64, 0x65, 0x66, 0x68, 0x94,
        0x98, 0xa7, 0x61, 0x67, 0x65, 0x67,
        0x9c, 0x6b
    };
    memmove(buf, dst, 6);
    memmove(buf + 6, src, 6);
    if (libnet_write_link_layer(l, dev, buf, sizeof buf) == -1) {
        error(EXIT_FAILURE, 0, "libnet_write_link_layer: error");
    }
}

void send_eap_identity(struct libnet_link_int *l,
                       struct ether_addr *dst, struct ether_addr *src,
                       u_char id, char *username)
{
    assert(l != NULL && dst != NULL && src != NULL && username != NULL);

    u_char buf[1024];
    uint16_t len;

    len = 5 + strlen(username);
    memmove(buf, dst, 6);
    memmove(buf + 6, src, 6);
    buf[ETHER_TYPE] = 0x88;
    buf[ETHER_TYPE + 1] = 0x8E;
    buf[ETHER_VERSION] = 0x01;
    *((uint16_t *) & buf[EAPOL_LEN]) = htons(len);
    buf[EAPOL_TYPE] = EAP_PACKET;
    buf[EAP_CODE] = EAP_RESPONSE;
    buf[EAP_ID] = id;
    buf[EAP_LEN] = len >> 8;
    buf[EAP_LEN + 1] = len & 0xFF;
    buf[EAP_TYPE] = 1;
    memmove(&buf[EAP_TYPE + 1], username, strlen(username));
    memmove(&buf[EAP_TYPE + 1 + strlen(username)], ruijie2,
            sizeof(ruijie2));
    if (libnet_write_link_layer(l, dev, buf, len + sizeof(ruijie2) + 18) ==
        -1) {
        error(EXIT_FAILURE, 0, "libnet_write_link_layer: error");
    }
}

void send_eap_md5(struct libnet_link_int *l,
                  struct ether_addr *dst, struct ether_addr *src,
                  u_char id, const char *username, const char *password,
                  u_char * packet, u_char length)
{
    u_char buf[1024];
    uint16_t len;

    len = 5 + 1 + 16 + strlen(username);
    memmove(buf, dst, 6);
    memmove(buf + 6, src, 6);
    buf[ETHER_TYPE] = 0x88;
    buf[ETHER_TYPE + 1] = 0x8E;
    buf[ETHER_VERSION] = 0x01;
    *((uint16_t *) & buf[EAPOL_LEN]) = htons(len);
    buf[EAPOL_TYPE] = EAP_PACKET;
    buf[EAP_CODE] = EAP_RESPONSE;
    buf[EAP_ID] = id;
    buf[EAP_LEN] = len >> 8;
    buf[EAP_LEN + 1] = len & 0xFF;
    buf[EAP_TYPE] = 4;
    buf[EAP_TYPE + 1] = 0x10;

    MD5_CTX context;

    MD5Init(&context);
    MD5Update(&context, &id, 1);
    MD5Update(&context, (u_char *) password, strlen(password));
    MD5Update(&context, packet, length);
    MD5Final(&buf[EAP_TYPE + 2], &context);

    memmove(&buf[EAP_TYPE + 18], username, strlen(username));
    memmove(&buf[EAP_TYPE + 18 + strlen(username)], ruijie3,
            sizeof(ruijie3));
    if (libnet_write_link_layer(l, dev, buf, 18 + len + sizeof(ruijie3)) ==
        -1) {
        error(EXIT_FAILURE, 0, "libnet_write_link_layer: error");
    }
}


void send_eap_echo(struct libnet_link_int *l,
                   struct ether_addr *dst, struct ether_addr *src,
                   uint32_t key)
{
    static u_char echoPackage[] = {     //echo包，用于每5秒钟激活一次
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x88, 0x8E, 0x01, 0xBF,
        0x00, 0x1E, 0xFF, 0xFF, 0x37, 0x77, 0x7F, 0x9F, 0xFF, 0xFF, 0xD9,
            0x13, 0xFF, 0xFF, 0x37, 0x77,
        0x7F, 0x9F, 0xFF, 0xFF, 0xF7, 0x28, 0xFF, 0xFF, 0x37, 0x77, 0x7F,
            0x3F, 0xFF
    };

    uint32_t dd1 = htonl(my_key + serialNO), dd2 = htonl(serialNO);
    u_char *bt1 = (u_char *) & dd1, *bt2 = (u_char *) & dd2;

    serialNO++;
    int i;

    for (i = 0; i < 4; i++) {
        echoPackage[0x18 + i] = encode(bt1[i]);
        echoPackage[0x22 + i] = encode(bt2[i]);
    }

    memcpy(echoPackage, dst, 6);
    memcpy(echoPackage + 6, src, 6);

    if (libnet_write_link_layer(l, dev, echoPackage, 0x2d) == -1)
        error(EXIT_FAILURE, 0, "libnet_write_link_layer() error");
}


unsigned char Alog(unsigned char BForAlog)
{
    int a = 0, b = 0, c = 0, d = 0, iRt;

    a = BForAlog;
    c = a;
    d = a;
    c &= 0x40;
    b = a;
    d >>= 2;
    c |= d;
    d = a;
    c >>= 2;
    d &= 0x20;
    c |= d;
    d = a;
    c >>= 2;
    d &= 0x10;
    c |= d;

    d = a;
    d &= 2;
    b <<= 2;
    d |= b;
    b = a;
    d <<= 2;
    b &= 4;
    a &= 8;
    d |= b;
    d <<= 2;
    d |= a;

    c >>= 1;
    d <<= 1;
    c |= d;
    iRt = (~c) & 0xff;
    return iRt;
}


u_char encode(u_char byte)
{
    u_char result = 0;
    int i;

    for (i = 0; i < 8; i++) {
        result <<= 1;
        result |= byte & 0x01;
        byte >>= 1;
    }
    return ~result;
}
